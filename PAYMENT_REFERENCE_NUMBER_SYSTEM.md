# Payment Reference Number System - Implementation Plan

## Overview

This document outlines the implementation of an auto-generated payment reference number system for all payments (both invoice-related and standalone credit payments). This will provide a unique, human-readable identifier for tracking and auditing payments.

## Current State Analysis

### Existing Payment Structure

**`payments` table columns:**
- `id` (UUID) - Internal database ID
- `invoice_id` (UUID, nullable) - Links to invoice (null for standalone credits)
- `transaction_id` (UUID) - Links to transaction record
- `amount` (NUMERIC) - Payment amount
- `payment_method` (ENUM) - Method of payment
- `payment_reference` (TEXT, nullable) - **User-provided reference** (check numbers, transaction IDs, etc.)
- `notes` (TEXT, nullable) - Additional notes
- `created_at`, `updated_at` - Timestamps

**Current Issues:**
1. ❌ No auto-generated unique reference for payments
2. ❌ `payment_reference` is user-provided and may be empty or non-unique
3. ❌ No easy way to reference a specific payment in conversation or documentation
4. ❌ Success messages don't show a trackable identifier
5. ❌ Difficult to search/reference specific payments without using UUIDs

### Invoice Number System (Reference)

Invoices use a sequential numbering system:
- Format: `INV-2025-01-0001` (Prefix-YearMonth-Sequence)
- Stored in: `invoice_sequences` table
- Generated by: `generate_invoice_number_with_prefix()` function
- Configuration: `INVOICE_CONFIG` constants in `src/constants/invoice.ts`

---

## Proposed Solution

### 1. Database Schema Changes

#### Add New Column: `payment_number`

```sql
-- Add new column for auto-generated payment reference
ALTER TABLE payments 
ADD COLUMN payment_number TEXT;

-- Create unique index to ensure no duplicates
CREATE UNIQUE INDEX idx_payments_payment_number_unique 
ON payments(payment_number) 
WHERE payment_number IS NOT NULL;

-- Add comment
COMMENT ON COLUMN payments.payment_number IS 'Auto-generated unique payment reference number (e.g., PAY-2025-10-0001). Distinct from user-provided payment_reference field.';
```

**Why a new column?**
- Keep `payment_reference` for user-provided data (check numbers, transaction IDs)
- `payment_number` will be system-generated and guaranteed unique
- Clear separation of concerns

#### Create Sequences Table: `payment_sequences`

```sql
-- Create payment sequences table (similar to invoice_sequences)
CREATE TABLE IF NOT EXISTS payment_sequences (
  year_month TEXT PRIMARY KEY,
  last_sequence INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Add index for performance
CREATE INDEX idx_payment_sequences_year_month ON payment_sequences(year_month);

-- Add comment
COMMENT ON TABLE payment_sequences IS 'Tracks sequential payment numbers by year-month for auto-generation';

-- Add RLS policy (read-only for authenticated users)
ALTER TABLE payment_sequences ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow authenticated users to view payment sequences"
  ON payment_sequences FOR SELECT
  TO authenticated
  USING (true);
```

---

### 2. Database Functions

#### Create `generate_payment_number()` Function

```sql
-- Generate sequential payment number with format: PAY-YYYY-MM-XXXX
CREATE OR REPLACE FUNCTION generate_payment_number()
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
  v_year_month TEXT;
  v_sequence INTEGER;
  v_payment_number TEXT;
BEGIN
  -- Get current year-month in YYYY-MM format
  v_year_month := TO_CHAR(CURRENT_DATE, 'YYYY-MM');
  
  -- Get or create sequence for this year-month (with row locking)
  INSERT INTO payment_sequences (year_month, last_sequence)
  VALUES (v_year_month, 1)
  ON CONFLICT (year_month)
  DO UPDATE SET 
    last_sequence = payment_sequences.last_sequence + 1,
    updated_at = NOW()
  RETURNING last_sequence INTO v_sequence;
  
  -- Format: PAY-YYYY-MM-XXXX (4-digit padding)
  v_payment_number := 'PAY-' || v_year_month || '-' || LPAD(v_sequence::TEXT, 4, '0');
  
  RETURN v_payment_number;
END;
$$;

-- Add comment
COMMENT ON FUNCTION generate_payment_number IS 'Generate unique sequential payment number in format PAY-YYYY-MM-XXXX';
```

#### Update `process_credit_payment_atomic()` Function

```sql
-- Update credit payment function to generate payment number
CREATE OR REPLACE FUNCTION process_credit_payment_atomic(
  p_user_id UUID,
  p_amount NUMERIC,
  p_payment_method TEXT,
  p_payment_reference TEXT DEFAULT NULL,
  p_notes TEXT DEFAULT NULL
) RETURNS JSONB
LANGUAGE plpgsql
AS $$
DECLARE
  v_user RECORD;
  v_payment_id UUID;
  v_transaction_id UUID;
  v_payment_number TEXT;  -- NEW
  v_result JSONB;
BEGIN
  BEGIN
    -- Validate user exists and get details
    SELECT 
      id,
      first_name,
      last_name,
      email
    INTO v_user
    FROM users 
    WHERE id = p_user_id
    FOR UPDATE;
    
    IF NOT FOUND THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'User not found',
        'user_id', p_user_id
      );
    END IF;
    
    -- Validate payment amount
    IF p_amount <= 0 THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Payment amount must be positive',
        'user_id', p_user_id
      );
    END IF;
    
    -- Validate payment method
    IF p_payment_method NOT IN ('cash', 'credit_card', 'debit_card', 'bank_transfer', 'check', 'online_payment', 'other') THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Invalid payment method',
        'user_id', p_user_id
      );
    END IF;
    
    -- Generate payment number (NEW)
    v_payment_number := generate_payment_number();
    
    -- Create credit transaction first
    INSERT INTO transactions (
      user_id,
      type,
      amount,
      description,
      metadata,
      status,
      completed_at
    ) VALUES (
      p_user_id,
      'credit',
      p_amount,
      'Credit payment received from ' || v_user.first_name || ' ' || v_user.last_name,
      jsonb_build_object(
        'user_id', p_user_id,
        'user_name', v_user.first_name || ' ' || v_user.last_name,
        'user_email', v_user.email,
        'transaction_type', 'credit_payment',
        'payment_method', p_payment_method,
        'payment_reference', p_payment_reference,
        'payment_number', v_payment_number,  -- NEW
        'notes', p_notes
      ),
      'completed',
      NOW()
    ) RETURNING id INTO v_transaction_id;
    
    -- Create payment record (with payment_number)
    INSERT INTO payments (
      invoice_id,
      transaction_id,
      amount,
      payment_method,
      payment_reference,
      payment_number,  -- NEW
      notes
    ) VALUES (
      NULL,
      v_transaction_id,
      p_amount,
      p_payment_method::payment_method,
      p_payment_reference,
      v_payment_number,  -- NEW
      p_notes
    ) RETURNING id INTO v_payment_id;
    
    -- Return success result (include payment_number)
    RETURN jsonb_build_object(
      'success', true,
      'payment_id', v_payment_id,
      'payment_number', v_payment_number,  -- NEW
      'transaction_id', v_transaction_id,
      'user_id', p_user_id,
      'user_name', v_user.first_name || ' ' || v_user.last_name,
      'amount', p_amount,
      'payment_method', p_payment_method,
      'message', 'Credit payment ' || v_payment_number || ' processed atomically'
    );
    
  EXCEPTION
    WHEN OTHERS THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', SQLERRM,
        'user_id', p_user_id,
        'message', 'Credit payment processing rolled back due to error'
      );
  END;
END;
$$;
```

#### Update `process_payment_atomic()` Function

Similar changes to the invoice payment function to include payment number generation.

```sql
CREATE OR REPLACE FUNCTION process_payment_atomic(
  p_invoice_id UUID,
  p_amount NUMERIC,
  p_payment_method TEXT,
  p_payment_reference TEXT DEFAULT NULL,
  p_notes TEXT DEFAULT NULL
) RETURNS JSONB
LANGUAGE plpgsql
AS $$
DECLARE
  v_invoice RECORD;
  v_payment_id UUID;
  v_transaction_id UUID;
  v_payment_number TEXT;  -- NEW
  v_remaining_balance NUMERIC;
  v_new_status TEXT;
  v_new_total_paid NUMERIC;
  v_total_credits NUMERIC;
  v_new_balance_due NUMERIC;
BEGIN
  BEGIN
    -- Get invoice details with lock
    SELECT * INTO v_invoice
    FROM invoices 
    WHERE id = p_invoice_id
    FOR UPDATE;
    
    IF NOT FOUND THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Invoice not found',
        'invoice_id', p_invoice_id
      );
    END IF;
    
    -- Validate payment amount
    IF p_amount <= 0 THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Payment amount must be positive',
        'invoice_id', p_invoice_id
      );
    END IF;
    
    -- Calculate total applied credit notes
    SELECT COALESCE(SUM(total_amount), 0)
    INTO v_total_credits
    FROM credit_notes
    WHERE original_invoice_id = p_invoice_id
      AND status = 'applied'
      AND deleted_at IS NULL;
    
    -- Calculate remaining balance
    SELECT COALESCE(v_invoice.total_amount - COALESCE(SUM(amount), 0) - v_total_credits, v_invoice.total_amount - v_total_credits)
    INTO v_remaining_balance
    FROM payments
    WHERE invoice_id = p_invoice_id;
    
    -- Validate payment doesn't exceed remaining balance
    IF p_amount > ROUND(v_remaining_balance, 2) THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Payment amount exceeds remaining balance',
        'remaining_balance', ROUND(v_remaining_balance, 2),
        'invoice_id', p_invoice_id
      );
    END IF;
    
    -- Generate payment number (NEW)
    v_payment_number := generate_payment_number();
    
    -- Create credit transaction
    INSERT INTO transactions (
      user_id,
      type,
      amount,
      description,
      metadata,
      status,
      completed_at
    ) VALUES (
      v_invoice.user_id,
      'credit',
      p_amount,
      'Payment for invoice: ' || v_invoice.invoice_number,
      jsonb_build_object(
        'invoice_id', p_invoice_id,
        'invoice_number', v_invoice.invoice_number,
        'payment_number', v_payment_number,  -- NEW
        'transaction_type', 'payment_credit'
      ),
      'completed',
      NOW()
    ) RETURNING id INTO v_transaction_id;
    
    -- Create payment record (with payment_number)
    INSERT INTO payments (
      invoice_id,
      transaction_id,
      amount,
      payment_method,
      payment_reference,
      payment_number,  -- NEW
      notes
    ) VALUES (
      p_invoice_id,
      v_transaction_id,
      p_amount,
      p_payment_method::payment_method,
      p_payment_reference,
      v_payment_number,  -- NEW
      p_notes
    ) RETURNING id INTO v_payment_id;
    
    -- Calculate new totals
    SELECT COALESCE(SUM(amount), 0)
    INTO v_new_total_paid
    FROM payments
    WHERE invoice_id = p_invoice_id;
    
    v_new_balance_due := ROUND(v_invoice.total_amount - v_new_total_paid - v_total_credits, 2);
    
    -- Update invoice
    UPDATE invoices 
    SET 
      total_paid = ROUND(v_new_total_paid, 2),
      balance_due = v_new_balance_due,
      updated_at = NOW()
    WHERE id = p_invoice_id;
    
    -- Update status if fully paid
    v_remaining_balance := v_new_balance_due;
    
    IF v_remaining_balance <= 0 THEN
      v_new_status := 'paid';
      UPDATE invoices 
      SET 
        status = 'paid'::invoice_status,
        paid_date = NOW(),
        updated_at = NOW()
      WHERE id = p_invoice_id;
    ELSE
      v_new_status := v_invoice.status;
    END IF;
    
    -- Return success result (include payment_number)
    RETURN jsonb_build_object(
      'success', true,
      'payment_id', v_payment_id,
      'payment_number', v_payment_number,  -- NEW
      'transaction_id', v_transaction_id,
      'invoice_id', p_invoice_id,
      'invoice_number', v_invoice.invoice_number,
      'new_status', v_new_status,
      'remaining_balance', v_remaining_balance,
      'total_paid', ROUND(v_new_total_paid, 2),
      'total_credits', v_total_credits,
      'message', 'Payment ' || v_payment_number || ' processed atomically'
    );
    
  EXCEPTION
    WHEN OTHERS THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', SQLERRM,
        'invoice_id', p_invoice_id,
        'message', 'Payment processing rolled back due to error'
      );
  END;
END;
$$;
```

---

### 3. TypeScript Type Updates

#### Update `src/types/payments.ts`

```typescript
export interface Payment {
  id: string;
  invoice_id: string | null;
  amount: number;
  payment_method: PaymentMethod;
  payment_reference: string | null; // User-provided reference (check #, transaction ID)
  payment_number: string | null; // NEW: Auto-generated payment reference (PAY-2025-10-0001)
  notes: string | null;
  transaction_id: string;
  created_at: string;
  updated_at: string;
  metadata?: PaymentMetadata;
}
```

---

### 4. API Route Updates

#### Update `src/app/api/payments/credit/route.ts`

```typescript
export async function POST(req: NextRequest) {
  const supabase = await createClient();
  
  // ... auth and validation code ...
  
  try {
    const { data: result, error } = await supabase.rpc('process_credit_payment_atomic', {
      p_user_id: user_id,
      p_amount: Number(amount),
      p_payment_method: payment_method,
      p_payment_reference: payment_reference || null,
      p_notes: notes || null
    });
    
    if (error) {
      console.error('Credit payment processing error:', error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    if (!result.success) {
      console.error('Credit payment processing failed:', result.error);
      return NextResponse.json({ 
        error: result.error,
        details: result
      }, { status: 400 });
    }
    
    console.log(`Credit payment ${result.payment_number} processed atomically: ${result.payment_id} for user ${result.user_name}`);
    
    // Return payment_number to frontend
    return NextResponse.json({ 
      id: result.payment_id,
      payment_number: result.payment_number, // NEW
      transaction_id: result.transaction_id,
      user_id: result.user_id,
      user_name: result.user_name,
      amount: result.amount,
      payment_method: result.payment_method,
      message: result.message
    });
  } catch (error) {
    console.error('Credit payment creation error:', error);
    return NextResponse.json({ 
      error: error instanceof Error ? error.message : 'Failed to process credit payment' 
    }, { status: 500 });
  }
}
```

#### Update `src/app/api/payments/route.ts`

Similar changes to include `payment_number` in the response.

---

### 5. UI Component Updates

#### Update `src/components/invoices/ReceivePaymentModal.tsx`

**Changes to state:**
```typescript
const [paymentNumber, setPaymentNumber] = React.useState<string | null>(null);
```

**Changes to submit handler:**
```typescript
async function handleSubmit(e: React.FormEvent) {
  e.preventDefault();
  setError(null);
  setSuccess(false);
  
  // ... validation ...
  
  setLoading(true);
  try {
    const res = await fetch("/api/payments/credit", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        user_id: selectedUser.id,
        amount: amount.toFixed(2),
        payment_method: method,
        payment_reference: reference || null,
        notes: notes || null,
      }),
    });
    
    if (!res.ok) {
      const err = await res.json();
      setError(err.error || "Failed to process credit payment.");
      setLoading(false);
      return;
    }
    
    const result = await res.json();
    
    // Store payment number for success message (NEW)
    setPaymentNumber(result.payment_number);
    
    // Show success state
    setSuccess(true);
    setLoading(false);
    
    // Wait a moment to show success message, then close and refresh
    setTimeout(() => {
      resetForm();
      onOpenChange(false);
      router.refresh();
    }, 2000); // Extended from 1500ms to allow reading payment number
    
  } catch (err: unknown) {
    if (err instanceof Error) {
      setError(err.message || "Failed to process credit payment.");
    } else {
      setError("Failed to process credit payment.");
    }
    setLoading(false);
  }
}
```

**Changes to success message:**
```typescript
{success ? (
  // Success state
  <div className="flex flex-col items-center justify-center py-12 px-6">
    <div className="bg-green-100 text-green-600 rounded-full p-4 mb-4">
      <CheckCircle className="w-12 h-12" />
    </div>
    <h3 className="text-xl font-bold text-green-600 mb-2">Payment Received!</h3>
    <p className="text-sm text-muted-foreground text-center mb-3">
      Credit payment of ${formatCurrencyDisplay(amount)} has been applied to {selectedUser?.first_name} {selectedUser?.last_name}&apos;s account.
    </p>
    {/* NEW: Display payment reference number */}
    {paymentNumber && (
      <div className="flex items-center gap-2 px-4 py-2 bg-white border border-green-200 rounded-lg">
        <Receipt className="w-4 h-4 text-green-600" />
        <div className="text-left">
          <div className="text-xs text-muted-foreground">Payment Reference</div>
          <div className="font-mono font-bold text-green-700">{paymentNumber}</div>
        </div>
      </div>
    )}
  </div>
) : (
  // ... existing form ...
)}
```

**Changes to reset function:**
```typescript
const resetForm = () => {
  setSelectedUser(null);
  setAmount(roundToTwoDecimals(defaultAmount || 0));
  setMethod("");
  setReference("");
  setNotes("");
  setError(null);
  setSuccess(false);
  setPaymentNumber(null); // NEW
};
```

---

### 6. Additional UI Updates

#### Payment History Displays

Update any components that display payment history to show the payment number:

**Example: Invoice Payment History**
```tsx
<div className="space-y-2">
  {payments.map((payment) => (
    <div key={payment.id} className="flex items-center justify-between p-3 bg-muted/50 rounded-lg">
      <div>
        <div className="flex items-center gap-2">
          <span className="font-mono text-sm font-semibold">{payment.payment_number}</span>
          <Badge variant="outline">{payment.payment_method}</Badge>
        </div>
        <div className="text-xs text-muted-foreground mt-1">
          {format(new Date(payment.created_at), 'MMM dd, yyyy HH:mm')}
        </div>
        {payment.payment_reference && (
          <div className="text-xs text-muted-foreground">
            Ref: {payment.payment_reference}
          </div>
        )}
      </div>
      <div className="font-semibold">${formatCurrencyDisplay(payment.amount)}</div>
    </div>
  ))}
</div>
```

#### Transaction History

Update transaction displays to include payment numbers when applicable:

```tsx
{transaction.metadata?.payment_number && (
  <div className="text-xs text-muted-foreground font-mono">
    Payment: {transaction.metadata.payment_number}
  </div>
)}
```

---

## 7. Migration Strategy

### Create Migration File: `20251008_add_payment_reference_numbers.sql`

```sql
-- =====================================================
-- Migration: Add Payment Reference Number System
-- =====================================================
-- Date: October 8, 2025
-- Description: Add auto-generated payment reference numbers
--              similar to invoice numbering system
-- =====================================================

BEGIN;

-- 1. Create payment_sequences table
CREATE TABLE IF NOT EXISTS payment_sequences (
  year_month TEXT PRIMARY KEY,
  last_sequence INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

CREATE INDEX idx_payment_sequences_year_month ON payment_sequences(year_month);

COMMENT ON TABLE payment_sequences IS 'Tracks sequential payment numbers by year-month for auto-generation';

-- Enable RLS
ALTER TABLE payment_sequences ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow authenticated users to view payment sequences"
  ON payment_sequences FOR SELECT
  TO authenticated
  USING (true);

-- 2. Add payment_number column to payments table
ALTER TABLE payments 
ADD COLUMN IF NOT EXISTS payment_number TEXT;

-- Create unique index
CREATE UNIQUE INDEX IF NOT EXISTS idx_payments_payment_number_unique 
ON payments(payment_number) 
WHERE payment_number IS NOT NULL;

COMMENT ON COLUMN payments.payment_number IS 'Auto-generated unique payment reference number (e.g., PAY-2025-10-0001). Distinct from user-provided payment_reference field.';

-- 3. Create payment number generation function
CREATE OR REPLACE FUNCTION generate_payment_number()
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
  v_year_month TEXT;
  v_sequence INTEGER;
  v_payment_number TEXT;
BEGIN
  v_year_month := TO_CHAR(CURRENT_DATE, 'YYYY-MM');
  
  INSERT INTO payment_sequences (year_month, last_sequence)
  VALUES (v_year_month, 1)
  ON CONFLICT (year_month)
  DO UPDATE SET 
    last_sequence = payment_sequences.last_sequence + 1,
    updated_at = NOW()
  RETURNING last_sequence INTO v_sequence;
  
  v_payment_number := 'PAY-' || v_year_month || '-' || LPAD(v_sequence::TEXT, 4, '0');
  
  RETURN v_payment_number;
END;
$$;

COMMENT ON FUNCTION generate_payment_number IS 'Generate unique sequential payment number in format PAY-YYYY-MM-XXXX';

-- 4. Backfill existing payments with payment numbers
-- Note: This runs once to give existing payments reference numbers
DO $$
DECLARE
  payment_record RECORD;
  new_payment_number TEXT;
BEGIN
  FOR payment_record IN 
    SELECT id, created_at 
    FROM payments 
    WHERE payment_number IS NULL 
    ORDER BY created_at ASC
  LOOP
    new_payment_number := generate_payment_number();
    UPDATE payments 
    SET payment_number = new_payment_number 
    WHERE id = payment_record.id;
  END LOOP;
END $$;

-- 5. Update process_credit_payment_atomic function
CREATE OR REPLACE FUNCTION process_credit_payment_atomic(
  p_user_id UUID,
  p_amount NUMERIC,
  p_payment_method TEXT,
  p_payment_reference TEXT DEFAULT NULL,
  p_notes TEXT DEFAULT NULL
) RETURNS JSONB
LANGUAGE plpgsql
AS $$
DECLARE
  v_user RECORD;
  v_payment_id UUID;
  v_transaction_id UUID;
  v_payment_number TEXT;
  v_result JSONB;
BEGIN
  BEGIN
    SELECT 
      id, first_name, last_name, email
    INTO v_user
    FROM users 
    WHERE id = p_user_id
    FOR UPDATE;
    
    IF NOT FOUND THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'User not found',
        'user_id', p_user_id
      );
    END IF;
    
    IF p_amount <= 0 THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Payment amount must be positive',
        'user_id', p_user_id
      );
    END IF;
    
    IF p_payment_method NOT IN ('cash', 'credit_card', 'debit_card', 'bank_transfer', 'check', 'online_payment', 'other') THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Invalid payment method',
        'user_id', p_user_id
      );
    END IF;
    
    -- Generate payment number
    v_payment_number := generate_payment_number();
    
    INSERT INTO transactions (
      user_id, type, amount, description, metadata, status, completed_at
    ) VALUES (
      p_user_id, 'credit', p_amount,
      'Credit payment received from ' || v_user.first_name || ' ' || v_user.last_name,
      jsonb_build_object(
        'user_id', p_user_id,
        'user_name', v_user.first_name || ' ' || v_user.last_name,
        'user_email', v_user.email,
        'transaction_type', 'credit_payment',
        'payment_method', p_payment_method,
        'payment_reference', p_payment_reference,
        'payment_number', v_payment_number,
        'notes', p_notes
      ),
      'completed', NOW()
    ) RETURNING id INTO v_transaction_id;
    
    INSERT INTO payments (
      invoice_id, transaction_id, amount, payment_method, 
      payment_reference, payment_number, notes
    ) VALUES (
      NULL, v_transaction_id, p_amount, p_payment_method::payment_method,
      p_payment_reference, v_payment_number, p_notes
    ) RETURNING id INTO v_payment_id;
    
    RETURN jsonb_build_object(
      'success', true,
      'payment_id', v_payment_id,
      'payment_number', v_payment_number,
      'transaction_id', v_transaction_id,
      'user_id', p_user_id,
      'user_name', v_user.first_name || ' ' || v_user.last_name,
      'amount', p_amount,
      'payment_method', p_payment_method,
      'message', 'Credit payment ' || v_payment_number || ' processed atomically'
    );
    
  EXCEPTION
    WHEN OTHERS THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', SQLERRM,
        'user_id', p_user_id,
        'message', 'Credit payment processing rolled back due to error'
      );
  END;
END;
$$;

-- 6. Update process_payment_atomic function (invoice payments)
CREATE OR REPLACE FUNCTION process_payment_atomic(
  p_invoice_id UUID,
  p_amount NUMERIC,
  p_payment_method TEXT,
  p_payment_reference TEXT DEFAULT NULL,
  p_notes TEXT DEFAULT NULL
) RETURNS JSONB
LANGUAGE plpgsql
AS $$
DECLARE
  v_invoice RECORD;
  v_payment_id UUID;
  v_transaction_id UUID;
  v_payment_number TEXT;
  v_remaining_balance NUMERIC;
  v_new_status TEXT;
  v_new_total_paid NUMERIC;
  v_total_credits NUMERIC;
  v_new_balance_due NUMERIC;
BEGIN
  BEGIN
    SELECT * INTO v_invoice
    FROM invoices 
    WHERE id = p_invoice_id
    FOR UPDATE;
    
    IF NOT FOUND THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Invoice not found',
        'invoice_id', p_invoice_id
      );
    END IF;
    
    IF p_amount <= 0 THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Payment amount must be positive',
        'invoice_id', p_invoice_id
      );
    END IF;
    
    SELECT COALESCE(SUM(total_amount), 0)
    INTO v_total_credits
    FROM credit_notes
    WHERE original_invoice_id = p_invoice_id
      AND status = 'applied'
      AND deleted_at IS NULL;
    
    SELECT COALESCE(v_invoice.total_amount - COALESCE(SUM(amount), 0) - v_total_credits, v_invoice.total_amount - v_total_credits)
    INTO v_remaining_balance
    FROM payments
    WHERE invoice_id = p_invoice_id;
    
    IF p_amount > ROUND(v_remaining_balance, 2) THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Payment amount exceeds remaining balance',
        'remaining_balance', ROUND(v_remaining_balance, 2),
        'invoice_id', p_invoice_id
      );
    END IF;
    
    -- Generate payment number
    v_payment_number := generate_payment_number();
    
    INSERT INTO transactions (
      user_id, type, amount, description, metadata, status, completed_at
    ) VALUES (
      v_invoice.user_id, 'credit', p_amount,
      'Payment for invoice: ' || v_invoice.invoice_number,
      jsonb_build_object(
        'invoice_id', p_invoice_id,
        'invoice_number', v_invoice.invoice_number,
        'payment_number', v_payment_number,
        'transaction_type', 'payment_credit'
      ),
      'completed', NOW()
    ) RETURNING id INTO v_transaction_id;
    
    INSERT INTO payments (
      invoice_id, transaction_id, amount, payment_method,
      payment_reference, payment_number, notes
    ) VALUES (
      p_invoice_id, v_transaction_id, p_amount, p_payment_method::payment_method,
      p_payment_reference, v_payment_number, p_notes
    ) RETURNING id INTO v_payment_id;
    
    SELECT COALESCE(SUM(amount), 0)
    INTO v_new_total_paid
    FROM payments
    WHERE invoice_id = p_invoice_id;
    
    v_new_balance_due := ROUND(v_invoice.total_amount - v_new_total_paid - v_total_credits, 2);
    
    UPDATE invoices 
    SET 
      total_paid = ROUND(v_new_total_paid, 2),
      balance_due = v_new_balance_due,
      updated_at = NOW()
    WHERE id = p_invoice_id;
    
    v_remaining_balance := v_new_balance_due;
    
    IF v_remaining_balance <= 0 THEN
      v_new_status := 'paid';
      UPDATE invoices 
      SET 
        status = 'paid'::invoice_status,
        paid_date = NOW(),
        updated_at = NOW()
      WHERE id = p_invoice_id;
    ELSE
      v_new_status := v_invoice.status;
    END IF;
    
    RETURN jsonb_build_object(
      'success', true,
      'payment_id', v_payment_id,
      'payment_number', v_payment_number,
      'transaction_id', v_transaction_id,
      'invoice_id', p_invoice_id,
      'invoice_number', v_invoice.invoice_number,
      'new_status', v_new_status,
      'remaining_balance', v_remaining_balance,
      'total_paid', ROUND(v_new_total_paid, 2),
      'total_credits', v_total_credits,
      'message', 'Payment ' || v_payment_number || ' processed atomically'
    );
    
  EXCEPTION
    WHEN OTHERS THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', SQLERRM,
        'invoice_id', p_invoice_id,
        'message', 'Payment processing rolled back due to error'
      );
  END;
END;
$$;

COMMIT;

-- Verification queries
SELECT 'Payment sequences table created:' as status, COUNT(*) as count FROM payment_sequences;
SELECT 'Payments with payment_number:' as status, COUNT(*) as count FROM payments WHERE payment_number IS NOT NULL;
SELECT 'Sample payment numbers:' as status, payment_number, amount, created_at FROM payments ORDER BY created_at DESC LIMIT 5;
```

---

## 8. Testing Plan

### Unit Tests

1. **Database Function Tests**
   - Test `generate_payment_number()` generates unique sequential numbers
   - Test format is correct: `PAY-YYYY-MM-XXXX`
   - Test sequence increments correctly within same month
   - Test sequence resets for new month
   - Test concurrent calls don't create duplicates

2. **API Tests**
   - Test `/api/payments/credit` returns payment_number
   - Test payment number is stored in database
   - Test payment number is unique

### Integration Tests

1. **Full Payment Flow**
   - Create credit payment via modal
   - Verify payment number is generated
   - Verify payment number is displayed in success message
   - Verify payment number appears in payment history

2. **Invoice Payment Flow**
   - Record payment on invoice
   - Verify payment number is generated
   - Verify payment number appears in invoice payment history

### Manual Testing Checklist

- [ ] Open Receive Payment modal
- [ ] Fill in payment details
- [ ] Submit payment
- [ ] Verify success message shows payment reference number
- [ ] Verify payment number format is correct (PAY-2025-10-XXXX)
- [ ] Check payment appears in transaction history
- [ ] Check payment number is visible in payment lists
- [ ] Verify payment can be searched by payment number
- [ ] Test with multiple sequential payments
- [ ] Verify numbers increment correctly

---

## 9. Documentation Updates

### Files to Update

1. **`RECEIVE_PAYMENT_MODAL_USAGE.md`**
   - Add section on payment reference numbers
   - Update success message screenshots
   - Document payment number format

2. **`CREDIT_PAYMENT_SYSTEM_IMPLEMENTATION.md`**
   - Add payment reference number documentation
   - Update API response examples

3. **`PAYMENT_SYSTEM_IMPLEMENTATION_SUMMARY.md`**
   - Document new payment_number field
   - Add to features list

4. **Database Schema Documentation**
   - Update payments table documentation
   - Document payment_sequences table
   - Document generate_payment_number function

---

## 10. Benefits

### User Benefits
- ✅ Easy reference for payment discussions ("I made payment PAY-2025-10-0042")
- ✅ Clear tracking in accounting and audit trails
- ✅ Professional appearance on receipts and communications
- ✅ Easy to search and filter payments

### Developer Benefits
- ✅ Consistent with invoice numbering system
- ✅ Unique identifier for logging and debugging
- ✅ Simple integration with existing codebase
- ✅ Atomic generation prevents duplicates

### Business Benefits
- ✅ Professional payment receipts
- ✅ Better audit trail for compliance
- ✅ Easier customer service (reference payment numbers)
- ✅ Improved payment reconciliation

---

## 11. Future Enhancements

### Phase 2 (Optional)
- Add payment number to email receipts
- Create printable payment receipt with payment number
- Add payment search by payment number
- Create payment number lookup API endpoint
- Add QR code with payment number to receipts
- Export payment reports grouped by payment number range

### Configurability
- Allow customization of payment number prefix in settings
- Allow customization of sequence padding
- Allow different formats for different payment types

---

## 12. Implementation Checklist

### Database
- [ ] Create migration file
- [ ] Create `payment_sequences` table
- [ ] Add `payment_number` column to `payments` table
- [ ] Create `generate_payment_number()` function
- [ ] Update `process_credit_payment_atomic()` function
- [ ] Update `process_payment_atomic()` function
- [ ] Backfill existing payments with payment numbers
- [ ] Test migration on staging database
- [ ] Run verification queries

### Backend
- [ ] Update TypeScript payment type definition
- [ ] Update `/api/payments/credit` route to return payment_number
- [ ] Update `/api/payments` route to return payment_number
- [ ] Add payment_number to API response logging
- [ ] Test API endpoints return correct data

### Frontend
- [ ] Update `ReceivePaymentModal` to display payment number
- [ ] Update payment history components to show payment number
- [ ] Update transaction history to show payment number
- [ ] Update invoice payment modals to show payment number
- [ ] Test UI displays payment numbers correctly
- [ ] Verify styling and responsive design

### Documentation
- [ ] Update `RECEIVE_PAYMENT_MODAL_USAGE.md`
- [ ] Update payment system documentation
- [ ] Update database schema documentation
- [ ] Create this implementation plan document
- [ ] Update API documentation

### Testing
- [ ] Write unit tests for payment number generation
- [ ] Write integration tests for payment flows
- [ ] Perform manual testing checklist
- [ ] Test concurrent payment creation
- [ ] Verify uniqueness constraints work

### Deployment
- [ ] Review all changes
- [ ] Run migration on staging
- [ ] Test on staging environment
- [ ] Deploy to production
- [ ] Monitor for errors
- [ ] Verify payment numbers generating correctly

---

## Summary

This implementation adds a professional auto-generated payment reference number system to all payments (both invoice and standalone credit payments). The payment number format (`PAY-YYYY-MM-XXXX`) is consistent with the existing invoice numbering system and provides an easy-to-reference identifier for all payment transactions.

The system maintains a clear separation between:
- **`payment_number`**: Auto-generated system reference (PAY-2025-10-0001)
- **`payment_reference`**: User-provided reference (check numbers, transaction IDs, etc.)

This ensures backwards compatibility while adding valuable new functionality for tracking and auditing payments.

